<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Project 2</title>
  <script src="https://d3js.org/d3.v5.min.js"></script>
  <link rel="stylesheet" type="text/css" href="all.css">
  <link href="https://fonts.googleapis.com/css?family=Aldrich|Audiowide|Fugaz+One|Gugi|Racing+Sans+One" rel="stylesheet">
</head>
<body>
<div id="header">
  <div id="title"><span>The Age of Residents Around a Restaraunt Doesn't Have Much Effect on its Rating</span></div><br/>
  <div id="leftP"><span>Anthony Verghese (akv26), Sam Ringel (sjr254), Isaiah Wilson (ijw23)</span></div>
  <div id="rightP"><span>INFO 3300</span></div>
</div>
<svg width="800" height="500" id="ageYelpPlot"></svg>
<div id="ourLegend" max-width = "800"></div>
<br/>
<br/>
<div id="ourAverages" max-width = "800"></div>
<div id="divForSlider"></div>
<script>
  let svg = d3.select("svg#ageYelpPlot");
  let width = svg.attr("width");
  let height = svg.attr("height");
  let margin = { top: 10, right: 10, bottom: 60, left: 60 };
  let chartWidth = width - margin.left - margin.right;
  let chartHeight = height - margin.top - margin.bottom;

  //key is category we will show, value is Yelp categories that count for it
  let mapofRestaurantTypes = {
    'American': ['American (Traditional)', 'American (New)'],
    'Fast Food': ['Fast Food'],
    'Mexican': ['Mexican'],
    'Sandwiches': ['Sandwiches'],
    'Pizza': ['Pizza'],
    'Breakfast & Brunch': ['Breakfast & Brunch'],
    'Burgers': ['Burgers'],
    'Chinese': ['Chinese'],
    'Italian': ['Italian'],
    'Seafood': ['Seafood'],
    'Japanese': ['Japanese']
  }
  let arrayOfRestaurantTypes = Object.keys(mapofRestaurantTypes);


  const requestData = async () => {
    //Pulling in the two datasets
    const ageData = await d3.csv("pop_mod.csv");
    const yelpData = await d3.json("zip_code_averages.json");

    const isValidZip = (zip) => {
      if (yelpData[zip] == null) return false;
      const cats = yelpData[zip]['cats'];
      for (key in mapofRestaurantTypes) {
        const value = mapofRestaurantTypes[key];
        if (cats[value[0]] != null) {
          if (value.length > 1 && cats[value[1]] != null) {
            if (cats[value[0]].count + cats[value[1]].count > 15) { return true; }
          } else if (cats[value[0]].count > 15) return true;
        } else if (value.length > 1 && cats[value[1]] != null && cats[value[1]].count > 15) return true;
      }
      return false
    }

    //ageScale is used for x axis
    const ageMin = d3.min(ageData, d => isValidZip(d.zip) ? d.age :  100);
    const ageMax = d3.max(ageData, d => isValidZip(d.zip) ? d.age : 0);
    const ageScale = d3.scaleLinear()
            .domain([ageMin - 1, ageMax + 1])
            .range([0, chartWidth]);

    const ageInvScale = d3.scaleLinear()
            .domain([0, chartWidth])
            .range([ageMin - 1, ageMax + 1])

    //rating scale is used for y axis
    const ratingScale = d3.scaleLinear()
            .domain([0, 5])
            .range([chartHeight, 0]);

    const ratingInvScale = d3.scaleLinear()
            .domain([chartHeight, 0])
            .range([0,5])

    const colorScale = d3.scaleOrdinal()
      .domain(arrayOfRestaurantTypes)
      .range(['#a6cee3','#1f78b4','#b2df8a','#33a02c','#fb9a99','#e31a1c','#fdbf6f','#ff7f00','#cab2d6','#6a3d9a','Brown']);

     // Y axis ticks
     let leftAxis = d3.axisLeft(ratingScale).ticks(5, d3.format(".1s"));
     svg.append("g").attr("class", "ticks")
       .attr("transform","translate("+ (margin.left-10) +","+ margin.top +")")
       .call(leftAxis);

     // X axis ticks
     let bottomAxis = d3.axisBottom(ageScale).ticks(8, d3.format("0s"));
     let element = svg.append("g").attr("class", "ticks")
       .attr("transform","translate("+ margin.left +","+ (margin.top + chartHeight + 10) +")");
     bottomAxis(element);

     // Y axis gridlines
     let leftGridlines = d3.axisLeft(ratingScale).tickSize(-chartWidth-10).tickFormat("");
     svg.append("g").attr("class", "gridlines")
       .attr("transform","translate("+ (margin.left-10) +","+ margin.top +")")
       .call(leftGridlines);

     // X axis gridlines
     let bottomGridlines = d3.axisBottom(ageScale).tickSize(-chartHeight-10).tickFormat("");
     element = svg.append("g").attr("class", "gridlines")
       .attr("transform","translate("+ margin.left +","+ (margin.top + chartHeight + 10) +")");
     bottomGridlines(element);

     svg.append("text")
        .attr("x", (width/2))
        .attr("y", chartHeight + margin.bottom+5)
        .text("Average resident age");


     svg.append("text")
        .attr("transform", "translate("+ (-235) +","+ ((height/2)+50) +") rotate(-90)")
        .attr("x", margin.left)
        .attr("y", (height/2))
        .text("Average Yelp rating");

    let scatter = svg.append("g")
           .attr("transform","translate("+margin.left+","+margin.top+")");

    let pointsData = [];

    ageData.forEach(function (d) {
      if (yelpData[d.zip] != null) {
        const cats = yelpData[d.zip]['cats'];
        Object.entries(mapofRestaurantTypes).forEach((mapping) => {
          const key = mapping[0];
          const value = mapping[1];
          let score;
          let count = 0;
          if (cats[value[0]] != null) {
            if (value.length > 1 && cats[value[1]] != null) {
              count = cats[value[0]].count + cats[value[1]].count;
              score = cats[value[0]].star_total + cats[value[1]].star_total;
            } else {
              count = cats[value[0]].count;
              score = cats[value[0]].star_total;
            }
          } else if (value.length > 1 && cats[value[1]] != null) {
            count = cats[value[1]].count;
            score = cats[value[1]].star_total;
          }
          if (score != undefined && count >= 5) {
            pointsData.push({
              age: d.age.toString(),
              rating: score / count,
              cat: key,
              zip: d.zip,
              city: yelpData[d.zip].city,
              state: yelpData[d.zip].state,
              key: key.split(' ')[0]
            })
          }
        })
      }
    });

    let points = scatter.selectAll('circle').data(pointsData)

    points.enter().append("circle")
        .attr("cx", d => ageScale(d.age))
        .attr("cy", d => ratingScale(d.rating))
        .attr("r", 4)
        .attr("opacity", 0.8)
        .style("fill", d => colorScale(d.cat))
        .attr("zip", d => d.zip)
        .attr("city", d => d.city + ", " + d.state)
        .attr("id", d => "C" + d.zip + d.key)
        .attr("restaurantType", d => d.key)
        .on("mouseover", d => {
          scatter.append("text")
            .attr("id", "A" + d.zip + d.key)
            .attr("x", ageScale(d.age) - 80)
            .attr("y", ratingScale(d.rating) - 15)
            .text("City: " + d.city + ", " + d.state)
          scatter.selectAll("circle").each(function() {
            let circleWithSameZip = d3.select(this);
            if (circleWithSameZip.attr("city") === d.city + ", " + d.state) {
              circleWithSameZip.attr("opacity", 0.8).attr("r", 6);
            }
            else {
              circleWithSameZip.attr("opacity", 0.1);
            }
          })
        })
        .on("mouseout", d => {
          d3.select("#A" + d.zip + d.key).remove();
          scatter.selectAll("circle").each(function() {
            let circle = d3.select(this);
            circle.attr("opacity", 0.8).attr("r", 4);
          })
        })

    // let ageCompValue = Math.round((ageMin + ageMax)/2);
    let ageCompValue = 40;
    var slidersDiv = d3.select("#divForSlider").append("div");
    slidersDiv.append("div").text("Age to Compare Against")
        .append("div").append("input")
        .attr("type", "range")
        .style("width","300px")
        .attr("min", Math.round(ageMin))
        .attr("max", Math.round(ageMax))
        .attr("step", 1)
        .attr("value",ageCompValue)
        .on("input", function () {
          ageCompValue = Number(this.value);
          //Call showCircles with the hue value selected on the slider
          // showCircles(Number(this.value));
        });

    let isCatDisplayeds = {}
    arrayOfRestaurantTypes.forEach((title) => {
      isCatDisplayeds[title] = true
    })

    const changeCats = (cats, isAdding) => {
      cats.forEach((cat) => {
        isCatDisplayeds[cat] = isAdding
      })

      scatter.selectAll('circle').data(pointsData).style("display", d => isCatDisplayeds[d.cat] ? "" : "none")
    }

    d3.select("#ourLegend")
          .append("button")
          .text("Select all")
          .attr("class", "allbutton")
          .on("click", () => {
            changeCats(arrayOfRestaurantTypes, true)
            d3.selectAll("#ourLegend button.deselected").attr("class", "selected")
          })
    d3.select("#ourLegend")
          .append("button")
          .text("Deselect all")
          .attr("class", "allbutton")
          .on("click", () => {
            changeCats(arrayOfRestaurantTypes, false)
            d3.selectAll("#ourLegend button.selected").attr("class", "deselected")
          })

    //Legend for selecting data points based on category
    arrayOfRestaurantTypes.forEach(d => {
        let selectDiv = d3.select("#ourLegend")
          .append("div")
          .attr("id", d.split(' ')[0] + "-select-div")

        selectDiv.append("button").text(d)
          .style("border-color", colorScale(d))
          .style("color", colorScale(d))
          .attr("class", "selected")
          /*.on("mouseover", function() {
            let totalRatingYoung = 0;
            let numYoung = 0;
            let totalRatingOld = 0;
            let numOld = 0;
            scatter.selectAll("circle").each(function() {
              let circle = d3.select(this);
              if (circle.attr("restaurantType") === d.split(' ')[0]) {
                circle.attr("opacity", 0.8);
                if (ageInvScale(circle.attr("cx")) < ageCompValue) {
                  totalRatingYoung = totalRatingYoung + ratingInvScale(circle.attr("cy"));
                  numYoung = numYoung + 1;
                } else {
                  totalRatingOld = totalRatingOld + ratingInvScale(circle.attr("cy"));
                  numOld = numOld + 1;
                }
              }
              else {
                circle.attr("opacity", 0.1);
              }
            })

            //I don't want NaN to be displayed, so rather than dividing by 0, I divide by 1
            if (numYoung == 0) {
              numYoung = 1;
            }
            if (numOld == 0) {
              numOld = 1;
            }
            d3.select("#ourAverages").html("")
              .append("p").text(d)
              .style("font-size", "25px")
              .style("padding", "30px")
              .style("margin-left", "50px")
              .style("margin-bottom", "30px")
              .style("color", colorScale(d))
              .append("p").text("Average Rating for Average Age younger than " + ageCompValue + ": " + Math.round(100*(totalRatingYoung/numYoung))/100)
              .append("p").text("Average Rating for Average Age older than " + ageCompValue + ": " + Math.round(100*(totalRatingOld/numOld))/100);
          })
          .on("mouseout", function() {
            scatter.selectAll("circle").each(function() {
              let circle = d3.select(this);
              circle.attr("opacity", 0.8);
            })
            d3.select("#ourAverages").html("");
          })*/
          .on("click", function() {
            d3.select(this).attr("class", isCatDisplayeds[d] ? "deselected" : "selected")
            changeCats([d], !isCatDisplayeds[d])
          })
        });
  }
  requestData();

</script>
</body>
</html>
